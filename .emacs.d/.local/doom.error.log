# -*- lisp-interaction -*-
# vim: set ft=lisp:

(error "Could not find package git-commit. Updating recipe repositories: (org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror) with `straight-pull-recipe-repositories' may fix this")

(signal error ("Could not find package git-commit. Updating recipe repositories: (org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror) with `straight-pull-recipe-repositories' may fix this"))

(error "Could not find package %S. Updating recipe repositories: %S with `straight-pull-recipe-repositories' may fix this" git-commit (org-elpa melpa gnu-elpa-mirror el-get emacsmirror-mirror))

(if (straight--package-built-in-p melpa-style-recipe) (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))) (error (concat "Could not find package %S. " "Updating recipe repositories: %S " "with `straight-pull-recipe-repositories' " "may fix this") melpa-style-recipe straight-recipe-repositories))

(or (straight-recipes-retrieve melpa-style-recipe nil cause) (if (straight--package-built-in-p melpa-style-recipe) (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))) (error (concat "Could not find package %S. " "Updating recipe repositories: %S " "with `straight-pull-recipe-repositories' " "may fix this") melpa-style-recipe straight-recipe-repositories)))

(if recipe-specified-p melpa-style-recipe (or (straight-recipes-retrieve melpa-style-recipe nil cause) (if (straight--package-built-in-p melpa-style-recipe) (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))) (error (concat "Could not find package %S. " "Updating recipe repositories: %S " "with `straight-pull-recipe-repositories' " "may fix this") melpa-style-recipe straight-recipe-repositories))))

(let* ((recipe-specified-p (listp melpa-style-recipe)) (full-melpa-style-recipe (if recipe-specified-p melpa-style-recipe (or (straight-recipes-retrieve melpa-style-recipe nil cause) (if (straight--package-built-in-p melpa-style-recipe) (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))) (error (concat "Could not find package %S. " "Updating recipe repositories: %S " "with `straight-pull-recipe-repositories' " "may fix this") melpa-style-recipe straight-recipe-repositories)))))) (if (straight--quoted-form-p full-melpa-style-recipe) (progn (setq full-melpa-style-recipe (eval full-melpa-style-recipe)))) (let* ((plist full-melpa-style-recipe) (package (if plist (car-safe (prog1 plist (setq plist (cdr plist)))) (signal 'wrong-number-of-arguments (list '(package . plist) (length plist)))))) (progn (let* ((inherit (plist-member plist :inherit)) (inheritance (if inherit (car (cdr inherit)) straight-allow-recipe-inheritance))) (if inheritance (progn (let* ((sources (plist-get plist :source)) (default (or (let* ((retrieved (and t (straight-recipes-retrieve package (if (listp sources) sources (list sources)))))) (if retrieved (cdr (if (straight--quoted-form-p retrieved) (eval retrieved) retrieved)) nil)) plist)) (type (if (plist-member default :type) (plist-get default :type) straight-default-vc)) (keywords (append straight--build-keywords (straight-vc-keywords type)))) (let* ((fork (and t (plist-get plist :fork)))) (if fork (progn (progn (setq default (copy-sequence default)) (setq default (plist-put default :fork fork))) (if (listp fork) nil (setq fork 'nil)) (progn (setq fork (copy-sequence fork)) (setq fork (plist-put fork :repo (straight-vc-git--fork-repo default)))) (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :fork fork)))) nil)) (let ((--dolist-tail-- keywords)) (while --dolist-tail-- (let ((keyword (car --dolist-tail--))) (if (plist-member plist keyword) nil (let* ((value (and t (plist-get default keyword)))) (if value (setq plist (plist-put plist keyword value)) nil))) (setq --dolist-tail-- (cdr --dolist-tail--))))))))) (let ((package (symbol-name package))) (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :package package))) (if (plist-member plist :type) nil (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :type straight-default-vc)))) (if (or (plist-member plist :local-repo) (eq (plist-get plist :type) 'built-in)) nil (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :local-repo (or (straight-vc-local-repo-name plist) package))))) (if recipe-specified-p nil (let* ((--cl-rest-- plist) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo))))) (let* ((original-recipe (and t (gethash local-repo straight--repo-cache)))) (if original-recipe (progn (let ((props (cons :type (straight-vc-keywords (plist-get plist :type))))) (setq plist (let* ((--cl-var-- plist) (prop nil) (val nil) (--cl-var--) (--cl-var-- nil)) (while (consp --cl-var--) (setq --cl-var-- --cl-var-- prop (car-safe (prog1 --cl-var-- (setq --cl-var-- (cdr --cl-var--)))) val (car --cl-var--)) (if (memq prop props) (progn) (setq --cl-var-- (cons prop --cl-var--)) (setq --cl-var-- (cons val --cl-var--))) (setq --cl-var-- (cdr (cdr --cl-var--)))) (nreverse --cl-var--)))) (let ((--dolist-tail-- (cons :type (straight-vc-keywords (plist-get original-recipe :type))))) (while --dolist-tail-- (let ((keyword (car --dolist-tail--))) (let* ((value (and t (plist-get original-recipe keyword)))) (if value (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist keyword value))) nil)) (setq --dolist-tail-- (cdr --dolist-tail--)))))) nil)))) plist))))

(or (and (symbolp melpa-style-recipe) (gethash (symbol-name melpa-style-recipe) straight--recipe-cache)) (let* ((recipe-specified-p (listp melpa-style-recipe)) (full-melpa-style-recipe (if recipe-specified-p melpa-style-recipe (or (straight-recipes-retrieve melpa-style-recipe nil cause) (if (straight--package-built-in-p melpa-style-recipe) (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))) (error (concat "Could not find package %S. " "Updating recipe repositories: %S " "with `straight-pull-recipe-repositories' " "may fix this") melpa-style-recipe straight-recipe-repositories)))))) (if (straight--quoted-form-p full-melpa-style-recipe) (progn (setq full-melpa-style-recipe (eval full-melpa-style-recipe)))) (let* ((plist full-melpa-style-recipe) (package (if plist (car-safe (prog1 plist (setq plist (cdr plist)))) (signal 'wrong-number-of-arguments (list '(package . plist) (length plist)))))) (progn (let* ((inherit (plist-member plist :inherit)) (inheritance (if inherit (car (cdr inherit)) straight-allow-recipe-inheritance))) (if inheritance (progn (let* ((sources (plist-get plist :source)) (default (or (let* ((retrieved (and t (straight-recipes-retrieve package (if (listp sources) sources (list sources)))))) (if retrieved (cdr (if (straight--quoted-form-p retrieved) (eval retrieved) retrieved)) nil)) plist)) (type (if (plist-member default :type) (plist-get default :type) straight-default-vc)) (keywords (append straight--build-keywords (straight-vc-keywords type)))) (let* ((fork (and t (plist-get plist :fork)))) (if fork (progn (progn (setq default (copy-sequence default)) (setq default (plist-put default :fork fork))) (if (listp fork) nil (setq fork 'nil)) (progn (setq fork (copy-sequence fork)) (setq fork (plist-put fork :repo (straight-vc-git--fork-repo default)))) (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :fork fork)))) nil)) (let ((--dolist-tail-- keywords)) (while --dolist-tail-- (let ((keyword (car --dolist-tail--))) (if (plist-member plist keyword) nil (let* ((value (and t (plist-get default keyword)))) (if value (setq plist (plist-put plist keyword value)) nil))) (setq --dolist-tail-- (cdr --dolist-tail--))))))))) (let ((package (symbol-name package))) (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :package package))) (if (plist-member plist :type) nil (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :type straight-default-vc)))) (if (or (plist-member plist :local-repo) (eq (plist-get plist :type) 'built-in)) nil (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :local-repo (or (straight-vc-local-repo-name plist) package))))) (if recipe-specified-p nil (let* ((--cl-rest-- plist) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo))))) (let* ((original-recipe (and t (gethash local-repo straight--repo-cache)))) (if original-recipe (progn (let ((props (cons :type (straight-vc-keywords (plist-get plist :type))))) (setq plist (let* ((--cl-var-- plist) (prop nil) (val nil) (--cl-var--) (--cl-var-- nil)) (while (consp --cl-var--) (setq --cl-var-- --cl-var-- prop (car-safe (prog1 --cl-var-- (setq --cl-var-- (cdr --cl-var--)))) val (car --cl-var--)) (if (memq prop props) (progn) (setq --cl-var-- (cons prop --cl-var--)) (setq --cl-var-- (cons val --cl-var--))) (setq --cl-var-- (cdr (cdr --cl-var--)))) (nreverse --cl-var--)))) (let ((--dolist-tail-- (cons :type (straight-vc-keywords (plist-get original-recipe :type))))) (while --dolist-tail-- (let ((keyword (car --dolist-tail--))) (let* ((value (and t (plist-get original-recipe keyword)))) (if value (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist keyword value))) nil)) (setq --dolist-tail-- (cdr --dolist-tail--)))))) nil)))) plist)))))

(catch '--cl-block-straight--convert-recipe-- (if (memq melpa-style-recipe straight-built-in-pseudo-packages) (progn (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))))) (or (and (symbolp melpa-style-recipe) (gethash (symbol-name melpa-style-recipe) straight--recipe-cache)) (let* ((recipe-specified-p (listp melpa-style-recipe)) (full-melpa-style-recipe (if recipe-specified-p melpa-style-recipe (or (straight-recipes-retrieve melpa-style-recipe nil cause) (if (straight--package-built-in-p melpa-style-recipe) (throw '--cl-block-straight--convert-recipe-- (list ':type 'built-in ':package (symbol-name melpa-style-recipe))) (error (concat "Could not find package %S. " "Updating recipe repositories: %S " "with `straight-pull-recipe-repositories' " "may fix this") melpa-style-recipe straight-recipe-repositories)))))) (if (straight--quoted-form-p full-melpa-style-recipe) (progn (setq full-melpa-style-recipe (eval full-melpa-style-recipe)))) (let* ((plist full-melpa-style-recipe) (package (if plist (car-safe (prog1 plist (setq plist (cdr plist)))) (signal 'wrong-number-of-arguments (list '(package . plist) (length plist)))))) (progn (let* ((inherit (plist-member plist :inherit)) (inheritance (if inherit (car (cdr inherit)) straight-allow-recipe-inheritance))) (if inheritance (progn (let* ((sources (plist-get plist :source)) (default (or (let* ((retrieved (and t (straight-recipes-retrieve package (if (listp sources) sources (list sources)))))) (if retrieved (cdr (if (straight--quoted-form-p retrieved) (eval retrieved) retrieved)) nil)) plist)) (type (if (plist-member default :type) (plist-get default :type) straight-default-vc)) (keywords (append straight--build-keywords (straight-vc-keywords type)))) (let* ((fork (and t (plist-get plist :fork)))) (if fork (progn (progn (setq default (copy-sequence default)) (setq default (plist-put default :fork fork))) (if (listp fork) nil (setq fork 'nil)) (progn (setq fork (copy-sequence fork)) (setq fork (plist-put fork :repo (straight-vc-git--fork-repo default)))) (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :fork fork)))) nil)) (let ((--dolist-tail-- keywords)) (while --dolist-tail-- (let ((keyword (car --dolist-tail--))) (if (plist-member plist keyword) nil (let* ((value (and t (plist-get default keyword)))) (if value (setq plist (plist-put plist keyword value)) nil))) (setq --dolist-tail-- (cdr --dolist-tail--))))))))) (let ((package (symbol-name package))) (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :package package))) (if (plist-member plist :type) nil (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :type straight-default-vc)))) (if (or (plist-member plist :local-repo) (eq (plist-get plist :type) 'built-in)) nil (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist :local-repo (or (straight-vc-local-repo-name plist) package))))) (if recipe-specified-p nil (let* ((--cl-rest-- plist) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo))))) (let* ((original-recipe (and t (gethash local-repo straight--repo-cache)))) (if original-recipe (progn (let ((props (cons :type (straight-vc-keywords (plist-get plist :type))))) (setq plist (let* ((--cl-var-- plist) (prop nil) (val nil) (--cl-var--) (--cl-var-- nil)) (while (consp --cl-var--) (setq --cl-var-- --cl-var-- prop (car-safe (prog1 --cl-var-- (setq --cl-var-- (cdr --cl-var--)))) val (car --cl-var--)) (if (memq prop props) (progn) (setq --cl-var-- (cons prop --cl-var--)) (setq --cl-var-- (cons val --cl-var--))) (setq --cl-var-- (cdr (cdr --cl-var--)))) (nreverse --cl-var--)))) (let ((--dolist-tail-- (cons :type (straight-vc-keywords (plist-get original-recipe :type))))) (while --dolist-tail-- (let ((keyword (car --dolist-tail--))) (let* ((value (and t (plist-get original-recipe keyword)))) (if value (progn (setq plist (copy-sequence plist)) (setq plist (plist-put plist keyword value))) nil)) (setq --dolist-tail-- (cdr --dolist-tail--)))))) nil)))) plist))))))

(straight--convert-recipe git-commit nil)

(let ((recipe (straight--convert-recipe (or (straight--get-overridden-recipe (if (listp melpa-style-recipe) (car melpa-style-recipe) melpa-style-recipe)) melpa-style-recipe) cause))) (straight--register-recipe recipe) (let* ((--cl-rest-- recipe) (package (car (cdr (plist-member --cl-rest-- ':package)))) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo)))) (type (car (cdr (plist-member --cl-rest-- ':type))))) (progn (if (eq type 'built-in) (progn (throw '--cl-block-straight-use-package-- t))) (straight--transaction-exec (intern (format "use-package-%S-%S-%S" (secure-hash 'md5 (prin1-to-string recipe 'noescape)) (if (let ((object no-clone)) (and (not (memq object '(no-clone t))) (functionp object))) (random) no-clone) (if (let ((object no-build)) (and (not (memq object '(no-build t))) (functionp object))) (random) no-build))) :now #'(lambda nil (let ((already-registered (gethash package straight--success-cache)) (available (or (null local-repo) (straight--repository-is-available-p recipe)))) (if (if (let ((object no-clone)) (and (not (memq object '(no-clone t))) (functionp object))) (funcall no-clone package available) no-clone) (progn (throw '--cl-block-straight-use-package-- nil))) (if available nil (straight--clone-repository recipe cause)) (straight--make-build-cache-available) (let* ((no-build (or (null local-repo) (straight--build-disabled-p recipe) (if (let ((object no-build)) (and (not (memq object '(no-build t))) (functionp object))) (funcall no-build package) no-build))) (modified (or (and straight--packages-to-rebuild (or (eq straight--packages-to-rebuild :all) (gethash package straight--packages-to-rebuild)) (not (gethash package straight--packages-not-to-rebuild)) (puthash package t straight--packages-not-to-rebuild)) (straight--package-might-be-modified-p recipe no-build)))) (let ((func (intern (format "straight-recipes-%s-version" package))) (table (gethash (intern package) straight--recipe-lookup-cache))) (if (or modified (not (fboundp func)) (not (equal (and table (gethash 'version table)) (funcall func)))) (progn (remhash (intern package) straight--recipe-lookup-cache)))) (if no-build nil (straight--add-package-to-load-path recipe)) (run-hook-with-args 'straight-use-package-prepare-functions package) (if (boundp 'native-comp-deferred-compilation-deny-list) (progn (let* ((build (and t (car (cdr (plist-member recipe :build)))))) (if build (if (and (eq (car-safe build) :not) (member 'native-compile (cdr build))) (progn (setq native-comp-deferred-compilation-deny-list (let* ((va (format "^%s" (straight--build-dir package)))) (if (cl-member va native-comp-deferred-compilation-deny-list :test #'string=) native-comp-deferred-compilation-deny-list (cons va native-comp-deferred-compilation-deny-list)))))) nil)))) (if (and modified (not no-build)) (progn (run-hook-with-args 'straight-use-package-pre-build-functions package) (straight--build-package recipe cause))) (straight--declare-successful-build recipe) (if no-build nil (let ((--dolist-tail-- (straight--get-dependencies package))) (while --dolist-tail-- (let ((dependency (car --dolist-tail--))) (straight-use-package (intern dependency) nil nil cause) (setq --dolist-tail-- (cdr --dolist-tail--))))) (straight--add-package-to-info-path recipe) (straight--activate-package-autoloads recipe)) (if (and interactive (not already-registered)) (progn (straight--output (concat "If you want to keep %s, put " "(straight-use-package %s%S) " "in your init-file.") package "'" (intern package))))) (puthash package t straight--success-cache) t))))))

(catch '--cl-block-straight-use-package-- (let ((recipe (straight--convert-recipe (or (straight--get-overridden-recipe (if (listp melpa-style-recipe) (car melpa-style-recipe) melpa-style-recipe)) melpa-style-recipe) cause))) (straight--register-recipe recipe) (let* ((--cl-rest-- recipe) (package (car (cdr (plist-member --cl-rest-- ':package)))) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo)))) (type (car (cdr (plist-member --cl-rest-- ':type))))) (progn (if (eq type 'built-in) (progn (throw '--cl-block-straight-use-package-- t))) (straight--transaction-exec (intern (format "use-package-%S-%S-%S" (secure-hash 'md5 (prin1-to-string recipe 'noescape)) (if (let ((object no-clone)) (and (not (memq object '(no-clone t))) (functionp object))) (random) no-clone) (if (let ((object no-build)) (and (not (memq object '(no-build t))) (functionp object))) (random) no-build))) :now #'(lambda nil (let ((already-registered (gethash package straight--success-cache)) (available (or (null local-repo) (straight--repository-is-available-p recipe)))) (if (if (let ((object no-clone)) (and (not (memq object '(no-clone t))) (functionp object))) (funcall no-clone package available) no-clone) (progn (throw '--cl-block-straight-use-package-- nil))) (if available nil (straight--clone-repository recipe cause)) (straight--make-build-cache-available) (let* ((no-build (or (null local-repo) (straight--build-disabled-p recipe) (if (let ((object no-build)) (and (not (memq object '(no-build t))) (functionp object))) (funcall no-build package) no-build))) (modified (or (and straight--packages-to-rebuild (or (eq straight--packages-to-rebuild :all) (gethash package straight--packages-to-rebuild)) (not (gethash package straight--packages-not-to-rebuild)) (puthash package t straight--packages-not-to-rebuild)) (straight--package-might-be-modified-p recipe no-build)))) (let ((func (intern (format "straight-recipes-%s-version" package))) (table (gethash (intern package) straight--recipe-lookup-cache))) (if (or modified (not (fboundp func)) (not (equal (and table (gethash 'version table)) (funcall func)))) (progn (remhash (intern package) straight--recipe-lookup-cache)))) (if no-build nil (straight--add-package-to-load-path recipe)) (run-hook-with-args 'straight-use-package-prepare-functions package) (if (boundp 'native-comp-deferred-compilation-deny-list) (progn (let* ((build (and t (car (cdr (plist-member recipe :build)))))) (if build (if (and (eq (car-safe build) :not) (member 'native-compile (cdr build))) (progn (setq native-comp-deferred-compilation-deny-list (let* ((va (format "^%s" (straight--build-dir package)))) (if (cl-member va native-comp-deferred-compilation-deny-list :test #'string=) native-comp-deferred-compilation-deny-list (cons va native-comp-deferred-compilation-deny-list)))))) nil)))) (if (and modified (not no-build)) (progn (run-hook-with-args 'straight-use-package-pre-build-functions package) (straight--build-package recipe cause))) (straight--declare-successful-build recipe) (if no-build nil (let ((--dolist-tail-- (straight--get-dependencies package))) (while --dolist-tail-- (let ((dependency (car --dolist-tail--))) (straight-use-package (intern dependency) nil nil cause) (setq --dolist-tail-- (cdr --dolist-tail--))))) (straight--add-package-to-info-path recipe) (straight--activate-package-autoloads recipe)) (if (and interactive (not already-registered)) (progn (straight--output (concat "If you want to keep %s, put " "(straight-use-package %s%S) " "in your init-file.") package "'" (intern package))))) (puthash package t straight--success-cache) t)))))))

(straight-use-package git-commit no-clone)

(straight-register-package git-commit)

(let ((package (car --dolist-tail--))) (straight-register-package package) (let ((name (symbol-name package))) (add-to-list 'load-path (directory-file-name (straight--build-dir name))) (straight--load-package-autoloads name)) (setq --dolist-tail-- (cdr --dolist-tail--)))

(while --dolist-tail-- (let ((package (car --dolist-tail--))) (straight-register-package package) (let ((name (symbol-name package))) (add-to-list 'load-path (directory-file-name (straight--build-dir name))) (straight--load-package-autoloads name)) (setq --dolist-tail-- (cdr --dolist-tail--))))

(let ((--dolist-tail-- (cl-delete-duplicates packages :test #'equal))) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (straight-register-package package) (let ((name (symbol-name package))) (add-to-list 'load-path (directory-file-name (straight--build-dir name))) (straight--load-package-autoloads name)) (setq --dolist-tail-- (cdr --dolist-tail--)))))

(let (packages) (let ((--dolist-tail-- doom-packages)) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (let* ((--cl-rest-- package) (name (if --cl-rest-- (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(name &key recipe disable ignore &allow-other-keys) (length --cl-rest--))))) (recipe (car (cdr (plist-member --cl-rest-- ':recipe)))) (disable (car (cdr (plist-member --cl-rest-- ':disable)))) (ignore (car (cdr (plist-member --cl-rest-- ':ignore))))) (if ignore (straight-override-recipe (cons name '(:type built-in))) (if disable (let* ((var name)) (if (memql var doom-disabled-packages) (with-no-warnings doom-disabled-packages) (setq doom-disabled-packages (cons var doom-disabled-packages)))) (if recipe (progn (straight-override-recipe (cons name recipe)))) (setq packages (append packages (cons name (straight--get-dependencies name))))))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (let ((--dolist-tail-- (cl-delete-duplicates packages :test #'equal))) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (straight-register-package package) (let ((name (symbol-name package))) (add-to-list 'load-path (directory-file-name (straight--build-dir name))) (straight--load-package-autoloads name)) (setq --dolist-tail-- (cdr --dolist-tail--))))))

(progn (if doom-debug-p (progn (let ((inhibit-message (active-minibuffer-window))) (message #("DOOM Initializing straight.el" 0 5 (face font-lock-comment-face)))))) (setq doom-disabled-packages nil doom-packages (doom-package-list)) (let (packages) (let ((--dolist-tail-- doom-packages)) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (let* ((--cl-rest-- package) (name (if --cl-rest-- (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(name &key recipe disable ignore &allow-other-keys) (length --cl-rest--))))) (recipe (car (cdr (plist-member --cl-rest-- ':recipe)))) (disable (car (cdr (plist-member --cl-rest-- ':disable)))) (ignore (car (cdr (plist-member --cl-rest-- ':ignore))))) (if ignore (straight-override-recipe (cons name '(:type built-in))) (if disable (let* ((var name)) (if (memql var doom-disabled-packages) (with-no-warnings doom-disabled-packages) (setq doom-disabled-packages (cons var doom-disabled-packages)))) (if recipe (progn (straight-override-recipe (cons name recipe)))) (setq packages (append packages (cons name (straight--get-dependencies name))))))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (let ((--dolist-tail-- (cl-delete-duplicates packages :test #'equal))) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (straight-register-package package) (let ((name (symbol-name package))) (add-to-list 'load-path (directory-file-name (straight--build-dir name))) (straight--load-package-autoloads name)) (setq --dolist-tail-- (cdr --dolist-tail--)))))))

(if (or force-p (null doom-packages)) (progn (if doom-debug-p (progn (let ((inhibit-message (active-minibuffer-window))) (message #("DOOM Initializing straight.el" 0 5 (face font-lock-comment-face)))))) (setq doom-disabled-packages nil doom-packages (doom-package-list)) (let (packages) (let ((--dolist-tail-- doom-packages)) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (let* ((--cl-rest-- package) (name (if --cl-rest-- (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(name &key recipe disable ignore &allow-other-keys) (length --cl-rest--))))) (recipe (car (cdr (plist-member --cl-rest-- ':recipe)))) (disable (car (cdr (plist-member --cl-rest-- ':disable)))) (ignore (car (cdr (plist-member --cl-rest-- ':ignore))))) (if ignore (straight-override-recipe (cons name '(:type built-in))) (if disable (let* ((var name)) (if (memql var doom-disabled-packages) (with-no-warnings doom-disabled-packages) (setq doom-disabled-packages (cons var doom-disabled-packages)))) (if recipe (progn (straight-override-recipe (cons name recipe)))) (setq packages (append packages (cons name (straight--get-dependencies name))))))) (setq --dolist-tail-- (cdr --dolist-tail--))))) (let ((--dolist-tail-- (cl-delete-duplicates packages :test #'equal))) (while --dolist-tail-- (let ((package (car --dolist-tail--))) (straight-register-package package) (let ((name (symbol-name package))) (add-to-list 'load-path (directory-file-name (straight--build-dir name))) (straight--load-package-autoloads name)) (setq --dolist-tail-- (cdr --dolist-tail--))))))))

(doom-initialize-packages)

(doom-cli-packages-install)

(if noinstall-p (doom--print (doom--format (format (doom--output-class 'warn "Not installing plugins, as requested")))) (doom--print (doom--format (format "Installing plugins"))) (doom-cli-packages-install))

(let ((default-directory (doom-path "~"))) (if noconfig-p (doom--print (doom--format (format (doom--output-class 'warn "Not copying private config template, as requested")))) (if (and (not (file-directory-p doom-private-dir)) (not (getenv "DOOMDIR"))) (progn (let ((xdg-config-dir (or (getenv "XDG_CONFIG_HOME") "~/.config"))) (if (file-in-directory-p doom-emacs-dir xdg-config-dir) (progn (setq doom-private-dir (expand-file-name "doom/" xdg-config-dir))))))) (doom--print (doom--format (format (doom--output-class 'start "Creating %s") (doom--output-class 'relpath doom-private-dir)))) (make-directory doom-private-dir 'parents) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (doom--output-class 'success "Created %s") (doom--output-class 'relpath doom-private-dir))))) (mapc #'(lambda (file) (let* ((template file) (filename (if template (car-safe (prog1 template (setq template (cdr template)))) (signal 'wrong-number-of-arguments (list '(filename . template) (length template)))))) (if (let ((p (let ((file filename)) (and (stringp file) (let ((default-directory doom-private-dir)) (file-exists-p file)) file)))) (and p (expand-file-name p doom-private-dir))) (doom--print (doom--format (format (doom--output-class 'warn "%s already exists, skipping") filename))) (doom--print (doom--format (format (doom--output-class 'info "Creating %s%s") (doom--output-class 'relpath doom-private-dir) filename))) (let ((temp-file (doom-path doom-private-dir filename)) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-file-contents template)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))) (doom--print (doom--format (format (doom--output-class 'success "Done!"))))))) (list (cons "init.el" (doom-path doom-emacs-dir "init.example.el")) (cons "config.el" (doom-path doom-core-dir "templates/config.example.el")) (cons "packages.el" (doom-path doom-core-dir "templates/packages.example.el"))))) (doom-initialize-modules 'force 'no-config) (if noenv-p (doom--print (doom--format (format (doom--output-class 'warn "Not generating envvars file, as requested")))) (if (file-exists-p doom-env-file) (doom--print (doom--format (format (doom--output-class 'info "Envvar file already exists, skipping")))) (if (or doom-auto-accept (y-or-n-p "Generate an envvar file? (see `doom help env` for details)")) (progn (doom-cli-reload-env-file 'force-p))))) (if noinstall-p (doom--print (doom--format (format (doom--output-class 'warn "Not installing plugins, as requested")))) (doom--print (doom--format (format "Installing plugins"))) (doom-cli-packages-install)) (doom--print (doom--format (format "Regenerating autoloads files"))) (doom-autoloads-reload) (if nohooks-p (doom--print (doom--format (format (doom--output-class 'warn "Not deploying commit-msg and pre-push git hooks, as requested")))) (doom--print (doom--format (format "Deploying commit-msg and pre-push git hooks"))) (doom-cli--ci-deploy-hooks)) (cond (nofonts-p) (IS-WINDOWS (doom--print (doom--format (format (doom--output-class 'warn "Doom cannot install all-the-icons' fonts on Windows!\n")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (concat "You'll have to do so manually:\n\n" "  1. Launch Doom Emacs\n" "  2. Execute 'M-x all-the-icons-install-fonts' to download the fonts\n" "  3. Open the download location in windows explorer\n" "  4. Open each font file to install them")))))) ((or doom-auto-accept (y-or-n-p "Download and install all-the-icon's fonts?")) (require 'all-the-icons) (let ((window-system (cond (IS-MAC 'ns) (IS-LINUX 'x)))) (all-the-icons-install-fonts 'yes)))) (if (file-exists-p "~/.emacs") (progn (doom--print (doom--format (format (doom--output-class 'warn "A ~/.emacs file was detected. This conflicts with Doom and should be deleted!")))))) (doom--print (doom--format (format (doom--output-class 'success "\nFinished! Doom is ready to go!\n")))) (let ((temp-buffer (generate-new-buffer " *temp*"))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (insert-file-contents (doom-path doom-core-dir "templates/QUICKSTART_INTRO")) (doom--print (doom--format (format "%s" (buffer-string))))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer))))))

(let ((noconfig-p (cdr (assq 'noconfig-p --alist--))) (noenv-p (cdr (assq 'noenv-p --alist--))) (noinstall-p (cdr (assq 'noinstall-p --alist--))) (nofonts-p (cdr (assq 'nofonts-p --alist--))) (nohooks-p (cdr (assq 'nohooks-p --alist--)))) (doom--print (doom--format (format (doom--output-color 'green "Installing Doom Emacs!\n")))) (let ((default-directory (doom-path "~"))) (if noconfig-p (doom--print (doom--format (format (doom--output-class 'warn "Not copying private config template, as requested")))) (if (and (not (file-directory-p doom-private-dir)) (not (getenv "DOOMDIR"))) (progn (let ((xdg-config-dir (or (getenv "XDG_CONFIG_HOME") "~/.config"))) (if (file-in-directory-p doom-emacs-dir xdg-config-dir) (progn (setq doom-private-dir (expand-file-name "doom/" xdg-config-dir))))))) (doom--print (doom--format (format (doom--output-class 'start "Creating %s") (doom--output-class 'relpath doom-private-dir)))) (make-directory doom-private-dir 'parents) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (doom--output-class 'success "Created %s") (doom--output-class 'relpath doom-private-dir))))) (mapc #'(lambda (file) (let* ((template file) (filename (if template (car-safe (prog1 template (setq template (cdr template)))) (signal 'wrong-number-of-arguments (list '(filename . template) (length template)))))) (if (let ((p (let ((file filename)) (and (stringp file) (let ((default-directory doom-private-dir)) (file-exists-p file)) file)))) (and p (expand-file-name p doom-private-dir))) (doom--print (doom--format (format (doom--output-class 'warn "%s already exists, skipping") filename))) (doom--print (doom--format (format (doom--output-class 'info "Creating %s%s") (doom--output-class 'relpath doom-private-dir) filename))) (let ((temp-file (doom-path doom-private-dir filename)) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-file-contents template)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))) (doom--print (doom--format (format (doom--output-class 'success "Done!"))))))) (list (cons "init.el" (doom-path doom-emacs-dir "init.example.el")) (cons "config.el" (doom-path doom-core-dir "templates/config.example.el")) (cons "packages.el" (doom-path doom-core-dir "templates/packages.example.el"))))) (doom-initialize-modules 'force 'no-config) (if noenv-p (doom--print (doom--format (format (doom--output-class 'warn "Not generating envvars file, as requested")))) (if (file-exists-p doom-env-file) (doom--print (doom--format (format (doom--output-class 'info "Envvar file already exists, skipping")))) (if (or doom-auto-accept (y-or-n-p "Generate an envvar file? (see `doom help env` for details)")) (progn (doom-cli-reload-env-file 'force-p))))) (if noinstall-p (doom--print (doom--format (format (doom--output-class 'warn "Not installing plugins, as requested")))) (doom--print (doom--format (format "Installing plugins"))) (doom-cli-packages-install)) (doom--print (doom--format (format "Regenerating autoloads files"))) (doom-autoloads-reload) (if nohooks-p (doom--print (doom--format (format (doom--output-class 'warn "Not deploying commit-msg and pre-push git hooks, as requested")))) (doom--print (doom--format (format "Deploying commit-msg and pre-push git hooks"))) (doom-cli--ci-deploy-hooks)) (cond (nofonts-p) (IS-WINDOWS (doom--print (doom--format (format (doom--output-class 'warn "Doom cannot install all-the-icons' fonts on Windows!\n")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (concat "You'll have to do so manually:\n\n" "  1. Launch Doom Emacs\n" "  2. Execute 'M-x all-the-icons-install-fonts' to download the fonts\n" "  3. Open the download location in windows explorer\n" "  4. Open each font file to install them")))))) ((or doom-auto-accept (y-or-n-p "Download and install all-the-icon's fonts?")) (require 'all-the-icons) (let ((window-system (cond (IS-MAC 'ns) (IS-LINUX 'x)))) (all-the-icons-install-fonts 'yes)))) (if (file-exists-p "~/.emacs") (progn (doom--print (doom--format (format (doom--output-class 'warn "A ~/.emacs file was detected. This conflicts with Doom and should be deleted!")))))) (doom--print (doom--format (format (doom--output-class 'success "\nFinished! Doom is ready to go!\n")))) (let ((temp-buffer (generate-new-buffer " *temp*"))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (insert-file-contents (doom-path doom-core-dir "templates/QUICKSTART_INTRO")) (doom--print (doom--format (format "%s" (buffer-string))))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))))

((closure ((plist) (aliases i) (name . install) t) (--alist--) (ignore --alist--) (let ((noconfig-p (cdr (assq 'noconfig-p --alist--))) (noenv-p (cdr (assq 'noenv-p --alist--))) (noinstall-p (cdr (assq 'noinstall-p --alist--))) (nofonts-p (cdr (assq 'nofonts-p --alist--))) (nohooks-p (cdr (assq 'nohooks-p --alist--)))) (doom--print (doom--format (format (doom--output-color 'green "Installing Doom Emacs!\n")))) (let ((default-directory (doom-path "~"))) (if noconfig-p (doom--print (doom--format (format (doom--output-class 'warn "Not copying private config template, as requested")))) (if (and (not (file-directory-p doom-private-dir)) (not (getenv "DOOMDIR"))) (progn (let ((xdg-config-dir (or (getenv "XDG_CONFIG_HOME") "~/.config"))) (if (file-in-directory-p doom-emacs-dir xdg-config-dir) (progn (setq doom-private-dir (expand-file-name "doom/" xdg-config-dir))))))) (doom--print (doom--format (format (doom--output-class 'start "Creating %s") (doom--output-class 'relpath doom-private-dir)))) (make-directory doom-private-dir 'parents) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (doom--output-class 'success "Created %s") (doom--output-class 'relpath doom-private-dir))))) (mapc #'(lambda (file) (let* ((template file) (filename (if template (car-safe (prog1 template (setq template (cdr template)))) (signal 'wrong-number-of-arguments (list '(filename . template) (length template)))))) (if (let ((p (let ((file filename)) (and (stringp file) (let ((default-directory doom-private-dir)) (file-exists-p file)) file)))) (and p (expand-file-name p doom-private-dir))) (doom--print (doom--format (format (doom--output-class 'warn "%s already exists, skipping") filename))) (doom--print (doom--format (format (doom--output-class 'info "Creating %s%s") (doom--output-class 'relpath doom-private-dir) filename))) (let ((temp-file (doom-path doom-private-dir filename)) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-file-contents template)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))) (doom--print (doom--format (format (doom--output-class 'success "Done!"))))))) (list (cons "init.el" (doom-path doom-emacs-dir "init.example.el")) (cons "config.el" (doom-path doom-core-dir "templates/config.example.el")) (cons "packages.el" (doom-path doom-core-dir "templates/packages.example.el"))))) (doom-initialize-modules 'force 'no-config) (if noenv-p (doom--print (doom--format (format (doom--output-class 'warn "Not generating envvars file, as requested")))) (if (file-exists-p doom-env-file) (doom--print (doom--format (format (doom--output-class 'info "Envvar file already exists, skipping")))) (if (or doom-auto-accept (y-or-n-p "Generate an envvar file? (see `doom help env` for details)")) (progn (doom-cli-reload-env-file 'force-p))))) (if noinstall-p (doom--print (doom--format (format (doom--output-class 'warn "Not installing plugins, as requested")))) (doom--print (doom--format (format "Installing plugins"))) (doom-cli-packages-install)) (doom--print (doom--format (format "Regenerating autoloads files"))) (doom-autoloads-reload) (if nohooks-p (doom--print (doom--format (format (doom--output-class 'warn "Not deploying commit-msg and pre-push git hooks, as requested")))) (doom--print (doom--format (format "Deploying commit-msg and pre-push git hooks"))) (doom-cli--ci-deploy-hooks)) (cond (nofonts-p) (IS-WINDOWS (doom--print (doom--format (format (doom--output-class 'warn "Doom cannot install all-the-icons' fonts on Windows!\n")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (concat "You'll have to do so manually:\n\n" "  1. Launch Doom Emacs\n" "  2. Execute 'M-x all-the-icons-install-fonts' to download the fonts\n" "  3. Open the download location in windows explorer\n" "  4. Open each font file to install them")))))) ((or doom-auto-accept (y-or-n-p "Download and install all-the-icon's fonts?")) (require 'all-the-icons) (let ((window-system (cond (IS-MAC 'ns) (IS-LINUX 'x)))) (all-the-icons-install-fonts 'yes)))) (if (file-exists-p "~/.emacs") (progn (doom--print (doom--format (format (doom--output-class 'warn "A ~/.emacs file was detected. This conflicts with Doom and should be deleted!")))))) (doom--print (doom--format (format (doom--output-class 'success "\nFinished! Doom is ready to go!\n")))) (let ((temp-buffer (generate-new-buffer " *temp*"))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (insert-file-contents (doom-path doom-core-dir "templates/QUICKSTART_INTRO")) (doom--print (doom--format (format "%s" (buffer-string))))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))))) nil)

(funcall (closure ((plist) (aliases i) (name . install) t) (--alist--) (ignore --alist--) (let ((noconfig-p (cdr (assq 'noconfig-p --alist--))) (noenv-p (cdr (assq 'noenv-p --alist--))) (noinstall-p (cdr (assq 'noinstall-p --alist--))) (nofonts-p (cdr (assq 'nofonts-p --alist--))) (nohooks-p (cdr (assq 'nohooks-p --alist--)))) (doom--print (doom--format (format (doom--output-color 'green "Installing Doom Emacs!\n")))) (let ((default-directory (doom-path "~"))) (if noconfig-p (doom--print (doom--format (format (doom--output-class 'warn "Not copying private config template, as requested")))) (if (and (not (file-directory-p doom-private-dir)) (not (getenv "DOOMDIR"))) (progn (let ((xdg-config-dir (or (getenv "XDG_CONFIG_HOME") "~/.config"))) (if (file-in-directory-p doom-emacs-dir xdg-config-dir) (progn (setq doom-private-dir (expand-file-name "doom/" xdg-config-dir))))))) (doom--print (doom--format (format (doom--output-class 'start "Creating %s") (doom--output-class 'relpath doom-private-dir)))) (make-directory doom-private-dir 'parents) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (doom--output-class 'success "Created %s") (doom--output-class 'relpath doom-private-dir))))) (mapc #'(lambda (file) (let* ((template file) (filename (if template (car-safe (prog1 template (setq template (cdr template)))) (signal 'wrong-number-of-arguments (list '(filename . template) (length template)))))) (if (let ((p (let ((file filename)) (and (stringp file) (let ((default-directory doom-private-dir)) (file-exists-p file)) file)))) (and p (expand-file-name p doom-private-dir))) (doom--print (doom--format (format (doom--output-class 'warn "%s already exists, skipping") filename))) (doom--print (doom--format (format (doom--output-class 'info "Creating %s%s") (doom--output-class 'relpath doom-private-dir) filename))) (let ((temp-file (doom-path doom-private-dir filename)) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-file-contents template)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))) (doom--print (doom--format (format (doom--output-class 'success "Done!"))))))) (list (cons "init.el" (doom-path doom-emacs-dir "init.example.el")) (cons "config.el" (doom-path doom-core-dir "templates/config.example.el")) (cons "packages.el" (doom-path doom-core-dir "templates/packages.example.el"))))) (doom-initialize-modules 'force 'no-config) (if noenv-p (doom--print (doom--format (format (doom--output-class 'warn "Not generating envvars file, as requested")))) (if (file-exists-p doom-env-file) (doom--print (doom--format (format (doom--output-class 'info "Envvar file already exists, skipping")))) (if (or doom-auto-accept (y-or-n-p "Generate an envvar file? (see `doom help env` for details)")) (progn (doom-cli-reload-env-file 'force-p))))) (if noinstall-p (doom--print (doom--format (format (doom--output-class 'warn "Not installing plugins, as requested")))) (doom--print (doom--format (format "Installing plugins"))) (doom-cli-packages-install)) (doom--print (doom--format (format "Regenerating autoloads files"))) (doom-autoloads-reload) (if nohooks-p (doom--print (doom--format (format (doom--output-class 'warn "Not deploying commit-msg and pre-push git hooks, as requested")))) (doom--print (doom--format (format "Deploying commit-msg and pre-push git hooks"))) (doom-cli--ci-deploy-hooks)) (cond (nofonts-p) (IS-WINDOWS (doom--print (doom--format (format (doom--output-class 'warn "Doom cannot install all-the-icons' fonts on Windows!\n")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (doom--print (doom--format (format (concat "You'll have to do so manually:\n\n" "  1. Launch Doom Emacs\n" "  2. Execute 'M-x all-the-icons-install-fonts' to download the fonts\n" "  3. Open the download location in windows explorer\n" "  4. Open each font file to install them")))))) ((or doom-auto-accept (y-or-n-p "Download and install all-the-icon's fonts?")) (require 'all-the-icons) (let ((window-system (cond (IS-MAC 'ns) (IS-LINUX 'x)))) (all-the-icons-install-fonts 'yes)))) (if (file-exists-p "~/.emacs") (progn (doom--print (doom--format (format (doom--output-class 'warn "A ~/.emacs file was detected. This conflicts with Doom and should be deleted!")))))) (doom--print (doom--format (format (doom--output-class 'success "\nFinished! Doom is ready to go!\n")))) (let ((temp-buffer (generate-new-buffer " *temp*"))) (save-current-buffer (set-buffer temp-buffer) (unwind-protect (progn (insert-file-contents (doom-path doom-core-dir "templates/QUICKSTART_INTRO")) (doom--print (doom--format (format "%s" (buffer-string))))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))))) nil)

(if cli (funcall (progn (or (and (memq (type-of cli) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cli))) (aref cli 7)) (doom--cli-process cli (remq nil args))) (user-error "Couldn't find any %S command" command))

(let* ((cli (and t (doom-cli-get command)))) (if cli (funcall (progn (or (and (memq (type-of cli) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cli))) (aref cli 7)) (doom--cli-process cli (remq nil args))) (user-error "Couldn't find any %S command" command)))

(doom-cli-execute "install")

(apply doom-cli-execute "install" nil)

(and t (apply #'doom-cli-execute command args))

(let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil))

(let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))

(let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil))))

(if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))

(cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil))))))

(catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))

(progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil))))))))

(unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))

(progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer))))

(unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old))

(let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old)))

(let ((message (symbol-function #'message))) (ignore message) (let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old))))

(let* ((log-buffer (generate-new-buffer " *doom log*")) (standard-output #'(lambda (out) (save-current-buffer (set-buffer log-buffer) (insert-char out)) (send-string-to-terminal (char-to-string out))))) (let ((message (symbol-function #'message))) (ignore message) (let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old)))))

(condition-case e (let* ((log-buffer (generate-new-buffer " *doom log*")) (standard-output #'(lambda (out) (save-current-buffer (set-buffer log-buffer) (insert-char out)) (send-string-to-terminal (char-to-string out))))) (let ((message (symbol-function #'message))) (ignore message) (let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old))))) (doom-cli-command-not-found-error (doom--print (doom--format (format (doom--output-class 'error "Command 'doom %s' not recognized") (string-join (cdr e) " ")))) (doom--print (doom--format (format "\nDid you mean one of these commands?"))) (apply #'doom-cli-execute "help" "--similar" (string-join (cdr e) " ")) 5) (doom-cli-wrong-number-of-arguments-error (let* ((--cl-rest-- (cdr e)) (route (if (= (length --cl-rest--) 5) (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(route opt arg n d) (length --cl-rest--))))) (opt (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (arg (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (n (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (d (car --cl-rest--))) (progn (doom--print (doom--format (format (doom--output-class 'error "doom %s: %S requires %d arguments, but %d given\n") (mapconcat #'symbol-name route " ") arg n d))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (apply #'doom-cli-execute "help" (mapcar #'symbol-name route))))) 6) (doom-cli-unrecognized-option-error (let ((option (car (cdr e)))) (doom--print (doom--format (format (doom--output-class 'error "Unrecognized option: %S") option))) (if (string-match "^--[^=]+=\\(.+\\)$" option) (progn (doom--print (doom--format (format "The %S syntax isn't supported. Use '%s %s' instead." option (car (split-string option "=")) (match-string 1 option))))))) 7) (doom-cli-deprecated-error (let* ((commands (cdr e)) (route (if commands (car-safe (prog1 commands (setq commands (cdr commands)))) (signal 'wrong-number-of-arguments (list '(route . commands) (length commands)))))) (progn (doom--print (doom--format (format (doom--output-class 'warn "The 'doom %s' command was removed and replaced with:\n") (mapconcat #'symbol-name route " ")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let ((--dolist-tail-- commands)) (while --dolist-tail-- (let ((command (car --dolist-tail--))) (doom--print (doom--format (format (doom--output-class 'info "%s") command))) (setq --dolist-tail-- (cdr --dolist-tail--)))))))) 8) (user-error (doom--print (doom--format (format (doom--output-class 'warn "%s") (car (cdr e))))) 9))

(let ((help-p (cdr (assq 'help-p --alist--))) (auto-accept-p (cdr (assq 'auto-accept-p --alist--))) (debug-p (cdr (assq 'debug-p --alist--))) (loadfile (cdr (assq 'loadfile --alist--))) (doomdir (cdr (assq 'doomdir --alist--))) (localdir (cdr (assq 'localdir --alist--))) (nocolor (cdr (assq 'nocolor --alist--))) (command (cdr (assq 'command --alist--))) (args (cdr (assq 'args --alist--)))) (condition-case e (let* ((log-buffer (generate-new-buffer " *doom log*")) (standard-output #'(lambda (out) (save-current-buffer (set-buffer log-buffer) (insert-char out)) (send-string-to-terminal (char-to-string out))))) (let ((message (symbol-function #'message))) (ignore message) (let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old))))) (doom-cli-command-not-found-error (doom--print (doom--format (format (doom--output-class 'error "Command 'doom %s' not recognized") (string-join (cdr e) " ")))) (doom--print (doom--format (format "\nDid you mean one of these commands?"))) (apply #'doom-cli-execute "help" "--similar" (string-join (cdr e) " ")) 5) (doom-cli-wrong-number-of-arguments-error (let* ((--cl-rest-- (cdr e)) (route (if (= (length --cl-rest--) 5) (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(route opt arg n d) (length --cl-rest--))))) (opt (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (arg (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (n (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (d (car --cl-rest--))) (progn (doom--print (doom--format (format (doom--output-class 'error "doom %s: %S requires %d arguments, but %d given\n") (mapconcat #'symbol-name route " ") arg n d))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (apply #'doom-cli-execute "help" (mapcar #'symbol-name route))))) 6) (doom-cli-unrecognized-option-error (let ((option (car (cdr e)))) (doom--print (doom--format (format (doom--output-class 'error "Unrecognized option: %S") option))) (if (string-match "^--[^=]+=\\(.+\\)$" option) (progn (doom--print (doom--format (format "The %S syntax isn't supported. Use '%s %s' instead." option (car (split-string option "=")) (match-string 1 option))))))) 7) (doom-cli-deprecated-error (let* ((commands (cdr e)) (route (if commands (car-safe (prog1 commands (setq commands (cdr commands)))) (signal 'wrong-number-of-arguments (list '(route . commands) (length commands)))))) (progn (doom--print (doom--format (format (doom--output-class 'warn "The 'doom %s' command was removed and replaced with:\n") (mapconcat #'symbol-name route " ")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let ((--dolist-tail-- commands)) (while --dolist-tail-- (let ((command (car --dolist-tail--))) (doom--print (doom--format (format (doom--output-class 'info "%s") command))) (setq --dolist-tail-- (cdr --dolist-tail--)))))))) 8) (user-error (doom--print (doom--format (format (doom--output-class 'warn "%s") (car (cdr e))))) 9)))

((closure ((plist) (aliases) (name . :doom) t) (--alist--) (ignore --alist--) (let ((help-p (cdr (assq 'help-p --alist--))) (auto-accept-p (cdr (assq 'auto-accept-p --alist--))) (debug-p (cdr (assq 'debug-p --alist--))) (loadfile (cdr (assq 'loadfile --alist--))) (doomdir (cdr (assq 'doomdir --alist--))) (localdir (cdr (assq 'localdir --alist--))) (nocolor (cdr (assq 'nocolor --alist--))) (command (cdr (assq 'command --alist--))) (args (cdr (assq 'args --alist--)))) (condition-case e (let* ((log-buffer (generate-new-buffer " *doom log*")) (standard-output #'(lambda (out) (save-current-buffer (set-buffer log-buffer) (insert-char out)) (send-string-to-terminal (char-to-string out))))) (let ((message (symbol-function #'message))) (ignore message) (let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old))))) (doom-cli-command-not-found-error (doom--print (doom--format (format (doom--output-class 'error "Command 'doom %s' not recognized") (string-join (cdr e) " ")))) (doom--print (doom--format (format "\nDid you mean one of these commands?"))) (apply #'doom-cli-execute "help" "--similar" (string-join (cdr e) " ")) 5) (doom-cli-wrong-number-of-arguments-error (let* ((--cl-rest-- (cdr e)) (route (if (= (length --cl-rest--) 5) (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(route opt arg n d) (length --cl-rest--))))) (opt (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (arg (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (n (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (d (car --cl-rest--))) (progn (doom--print (doom--format (format (doom--output-class 'error "doom %s: %S requires %d arguments, but %d given\n") (mapconcat #'symbol-name route " ") arg n d))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (apply #'doom-cli-execute "help" (mapcar #'symbol-name route))))) 6) (doom-cli-unrecognized-option-error (let ((option (car (cdr e)))) (doom--print (doom--format (format (doom--output-class 'error "Unrecognized option: %S") option))) (if (string-match "^--[^=]+=\\(.+\\)$" option) (progn (doom--print (doom--format (format "The %S syntax isn't supported. Use '%s %s' instead." option (car (split-string option "=")) (match-string 1 option))))))) 7) (doom-cli-deprecated-error (let* ((commands (cdr e)) (route (if commands (car-safe (prog1 commands (setq commands (cdr commands)))) (signal 'wrong-number-of-arguments (list '(route . commands) (length commands)))))) (progn (doom--print (doom--format (format (doom--output-class 'warn "The 'doom %s' command was removed and replaced with:\n") (mapconcat #'symbol-name route " ")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let ((--dolist-tail-- commands)) (while --dolist-tail-- (let ((command (car --dolist-tail--))) (doom--print (doom--format (format (doom--output-class 'info "%s") command))) (setq --dolist-tail-- (cdr --dolist-tail--)))))))) 8) (user-error (doom--print (doom--format (format (doom--output-class 'warn "%s") (car (cdr e))))) 9)))) ((command . "install")))

(funcall (closure ((plist) (aliases) (name . :doom) t) (--alist--) (ignore --alist--) (let ((help-p (cdr (assq 'help-p --alist--))) (auto-accept-p (cdr (assq 'auto-accept-p --alist--))) (debug-p (cdr (assq 'debug-p --alist--))) (loadfile (cdr (assq 'loadfile --alist--))) (doomdir (cdr (assq 'doomdir --alist--))) (localdir (cdr (assq 'localdir --alist--))) (nocolor (cdr (assq 'nocolor --alist--))) (command (cdr (assq 'command --alist--))) (args (cdr (assq 'args --alist--)))) (condition-case e (let* ((log-buffer (generate-new-buffer " *doom log*")) (standard-output #'(lambda (out) (save-current-buffer (set-buffer log-buffer) (insert-char out)) (send-string-to-terminal (char-to-string out))))) (let ((message (symbol-function #'message))) (ignore message) (let* ((vnew #'(lambda (msg &rest args) "\n\n(fn MSG &rest ARGS)" (progn (if msg (progn (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (save-current-buffer (set-buffer log-buffer) (insert (doom--format (apply #'format msg args)) "\n")) (if (or doom-debug-p (not inhibit-message)) (progn (doom--print (doom--format (apply #'format msg args)))))))) message))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (unwind-protect (progn (if nocolor (progn (setq doom-output-backend nil))) (catch 'exit (if (and (not (getenv "__DOOMRESTART")) (or doomdir localdir debug-p auto-accept-p)) (progn (if doomdir (progn (setenv "DOOMDIR" (file-name-as-directory doomdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMDIR=%s") doomdir))))) (if localdir (progn (setenv "DOOMLOCALDIR" (file-name-as-directory localdir)) (doom--print (doom--format (format (doom--output-class 'info "DOOMLOCALDIR=%s") localdir))))) (if debug-p (progn (setenv "DEBUG" "1") (doom--print (doom--format (format (doom--output-class 'info "DEBUG=1")))))) (if auto-accept-p (progn (setenv "YES" auto-accept-p) (doom--print (doom--format (format (doom--output-class 'info "Confirmations auto-accept enabled")))))) (throw 'exit "__DOOMRESTART=1 $@"))) (if loadfile (progn (load (doom-path loadfile) nil t t))) (if help-p (progn (if command (progn (setq args (cons command args)))) (setq command "help"))) (cons t (if (null command) (doom-cli-execute "help") (let ((start-time (current-time))) (run-hooks 'doom-cli-pre-hook) (if (getenv "__DOOMRESTART") nil (doom--print (doom--format (format (doom--output-class 'start "Executing 'doom %s' with Emacs %s at %s") (string-join (cons (or (condition-case nil (progn (let ((cl-x (doom-cli-get command))) (progn (or (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1)))) (error nil)) command) args) " ") emacs-version (format-time-string "%Y-%m-%d %H:%M:%S"))))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let* ((result (and t (apply #'doom-cli-execute command args)))) (if result (progn (run-hooks 'doom-cli-post-hook) (doom--print (doom--format (format (doom--output-class 'success "Finished in %s") (let* ((duration (float-time (time-subtract (current-time) before-init-time))) (hours (/ (truncate duration) 60 60)) (minutes (- (/ (truncate duration) 60) (* hours 60))) (seconds (- duration (* hours 60 60) (* minutes 60)))) (string-join (delq nil (list (if (= 0 hours) nil (format "%dh" hours)) (if (= 0 minutes) nil (format "%dm" minutes)) (format (if (> duration 60) "%ds" "%.4fs") seconds)))))))) result) nil)))))))) (save-current-buffer (set-buffer log-buffer) (require 'ansi-color) (ansi-color-filter-region (point-min) (point-max))) (let ((dest doom--cli-log-buffer)) (cond ((bufferp dest) (save-current-buffer (set-buffer dest) (insert-buffer-substring log-buffer))) ((stringp dest) (make-directory (file-name-directory dest) 'parents) (let ((temp-file dest) (temp-buffer (generate-new-buffer " *temp file*"))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (insert-buffer-substring log-buffer)) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) (kill-buffer log-buffer)))) (fset #'message old))))) (doom-cli-command-not-found-error (doom--print (doom--format (format (doom--output-class 'error "Command 'doom %s' not recognized") (string-join (cdr e) " ")))) (doom--print (doom--format (format "\nDid you mean one of these commands?"))) (apply #'doom-cli-execute "help" "--similar" (string-join (cdr e) " ")) 5) (doom-cli-wrong-number-of-arguments-error (let* ((--cl-rest-- (cdr e)) (route (if (= (length --cl-rest--) 5) (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--)))) (signal 'wrong-number-of-arguments (list '(route opt arg n d) (length --cl-rest--))))) (opt (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (arg (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (n (car-safe (prog1 --cl-rest-- (setq --cl-rest-- (cdr --cl-rest--))))) (d (car --cl-rest--))) (progn (doom--print (doom--format (format (doom--output-class 'error "doom %s: %S requires %d arguments, but %d given\n") (mapconcat #'symbol-name route " ") arg n d))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (apply #'doom-cli-execute "help" (mapcar #'symbol-name route))))) 6) (doom-cli-unrecognized-option-error (let ((option (car (cdr e)))) (doom--print (doom--format (format (doom--output-class 'error "Unrecognized option: %S") option))) (if (string-match "^--[^=]+=\\(.+\\)$" option) (progn (doom--print (doom--format (format "The %S syntax isn't supported. Use '%s %s' instead." option (car (split-string option "=")) (match-string 1 option))))))) 7) (doom-cli-deprecated-error (let* ((commands (cdr e)) (route (if commands (car-safe (prog1 commands (setq commands (cdr commands)))) (signal 'wrong-number-of-arguments (list '(route . commands) (length commands)))))) (progn (doom--print (doom--format (format (doom--output-class 'warn "The 'doom %s' command was removed and replaced with:\n") (mapconcat #'symbol-name route " ")))) (let ((doom-output-indent (+ doom-output-indent-increment doom-output-indent))) (let ((--dolist-tail-- commands)) (while --dolist-tail-- (let ((command (car --dolist-tail--))) (doom--print (doom--format (format (doom--output-class 'info "%s") command))) (setq --dolist-tail-- (cdr --dolist-tail--)))))))) 8) (user-error (doom--print (doom--format (format (doom--output-class 'warn "%s") (car (cdr e))))) 9)))) ((command . "install")))

(if cli (funcall (progn (or (and (memq (type-of cli) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cli))) (aref cli 7)) (doom--cli-process cli (remq nil args))) (user-error "Couldn't find any %S command" command))

(let* ((cli (and t (doom-cli-get command)))) (if cli (funcall (progn (or (and (memq (type-of cli) cl-struct-doom-cli-tags) t) (signal 'wrong-type-argument (list 'doom-cli cli))) (aref cli 7)) (doom--cli-process cli (remq nil args))) (user-error "Couldn't find any %S command" command)))

(doom-cli-execute :doom "install")
